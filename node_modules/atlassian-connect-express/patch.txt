diff --git a/lib/middleware/authentication.js b/lib/middleware/authentication.js
index 1a1a93b..72f6b38 100644
--- a/lib/middleware/authentication.js
+++ b/lib/middleware/authentication.js
@@ -71,6 +71,7 @@ function createSessionToken(addon, verifiedClaims, clientKey, settings) {
     iat: now.unix(),
     sub: verifiedClaims.sub,
     exp: now.add(addon.config.maxTokenAge(), "milliseconds").unix(),
+    qsh: "context-qsh",
     aud: [clientKey]
   };
 
@@ -116,8 +117,7 @@ async function getVerifiedClaims(addon, req, res, skipQshVerification) {
   }
 
   const queryStringHash = unverifiedClaims.qsh;
-  if (!queryStringHash && !skipQshVerification) {
-    // session JWT tokens don't require a qsh
+  if (!queryStringHash) {
     return Promise.reject({
       code: 401,
       message: "JWT claim did not contain the query string hash (qsh) claim",
@@ -187,7 +187,7 @@ async function getVerifiedClaims(addon, req, res, skipQshVerification) {
 
   // First check query string params
   const jwtRequest = jwt.fromExpressRequest(request);
-  if (!skipQshVerification && verifiedClaims.qsh) {
+  if (verifiedClaims.qsh) {
     let expectedHash = jwt.createQueryStringHash(
       jwtRequest,
       false,
@@ -195,37 +195,37 @@ async function getVerifiedClaims(addon, req, res, skipQshVerification) {
     );
     let signatureHashVerified = verifiedClaims.qsh === expectedHash;
     if (!signatureHashVerified) {
-      let canonicalRequest = jwt.createCanonicalRequest(
+      // If that didn't verify, it might be a post/put - check the request body too
+      expectedHash = jwt.createQueryStringHash(
         jwtRequest,
-        false,
+        true,
         addon.config.baseUrl.href
       );
+      signatureHashVerified = verifiedClaims.qsh === expectedHash;
+    }
 
-      // If that didn't verify, it might be a post/put - check the request body too
-      expectedHash = jwt.createQueryStringHash(
+    if (!signatureHashVerified && skipQshVerification) {
+      // we are not checking qsh value so check if this is a context JWT iwith a fixed qsh value
+      signatureHashVerified = verifiedClaims.qsh === "context-qsh";
+    }
+
+    if (!signatureHashVerified) {
+      const canonicalRequest = jwt.createCanonicalRequest(
         jwtRequest,
         true,
         addon.config.baseUrl.href
       );
-      signatureHashVerified = verifiedClaims.qsh === expectedHash;
-      if (!signatureHashVerified) {
-        canonicalRequest = jwt.createCanonicalRequest(
-          jwtRequest,
-          true,
-          addon.config.baseUrl.href
-        );
-
-        // Send the error message for the first verification - it's 90% more likely to be the one we want.
-        addon.logger.error(
-          `Auth failure: Query hash mismatch: Received: "${verifiedClaims.qsh}" but calculated "${expectedHash}". Canonical query was: "${canonicalRequest}`
-        );
-
-        return Promise.reject({
-          code: 401,
-          message: "Authentication failed: query hash does not match.",
-          ctx: {}
-        });
-      }
+
+      // Send the error message for the first verification - it's 90% more likely to be the one we want.
+      addon.logger.error(
+        `Auth failure: Query hash mismatch: Received: "${verifiedClaims.qsh}" but calculated "${expectedHash}". Canonical query was: "${canonicalRequest}`
+      );
+
+      return Promise.reject({
+        code: 401,
+        message: "Authentication failed: query hash does not match.",
+        ctx: {}
+      });
     }
   }
 
diff --git a/test/token.test.js b/test/token.test.js
index 3cf836f..4b1490f 100644
--- a/test/token.test.js
+++ b/test/token.test.js
@@ -134,6 +134,8 @@ describe("Token verification", () => {
 
     if (req) {
       jwtPayload.qsh = jwt.createQueryStringHash(jwt.fromExpressRequest(req));
+    } else {
+      jwtPayload.qsh = "context-qsh";
     }
 
     return jwt.encode(
